<!DOCTYPE html>

<script>

var paused = false;



var drawingVars = {
	"camAngle": 0,
	"scale": 0.3,
	"flywheelAngle": Math.PI/2,
	"planetAngle": Math.PI/2,
	"time delay": 50,
	"calc angle change": 0.06//Math.PI/36
	

}

var calculatedVars = {
"rvl": {"name": "True Valve Lift", "value": 0, "type": "length"},
"vlt": {"name": "Ideal Valve Lift", "value": 0, "type": "length"},
"cra": {"name": "Transmission Angle", "value": 0, "type": "angle"},
"mta": {"name": "Minimum Transmission Angle", "value": 0, "type": "angle"},
"rgd": {"name": "Ring Gear Diameter", "value": 0, "type": "length"},
"pgd": {"name": "Planet Gear Diameter", "value": 0, "type": "length"},
"lsr": {"name": "Long Stroke Length", "value": 0, "type": "length"},
"ssr": {"name": "Short Stroke Length", "value": 0, "type": "length"},
"cpi": {"name": "Cylinder-Piston Intersection Length", "value": 0, "type": "length"},
"rcb": {"name": "Ring Center to Lowest BDC", "value": 0, "type": "length"},
"msd": {"name": "Measured Distance", "value": 0, "type": "length"}

}


var currentUnits = {
	"length": "mm",
	"angle": "degrees",
	"pressure": "MPa",
	"speed": "m/s",
	"rpm": "rpm",
	"count": ""
}


var categoryUnits = {
	"length": {"mm": 1, "cm": 10, "m": 1000, "in": 25.4, "ft": 304.8},
	"angle": {"degrees": 1, "radians": Math.PI/180},
	"pressure": {"MPa": 1},
	"speed": {"m/s": 1},
	"rpm": {"rpm":1}
}

var allElements = [];





class CalcVar {
  constructor(name, value, type, category, dependents, dependentsShown, activated, element) {
    this.name = name
    this.value = value
    this.type = type
    this.category = category
    this.dependents = []
    this.dependentsShown = dependentsShown
    this.activated = activated
 	this.element = 0;
  }
}

vars = {
	"es": new CalcVar("Engine Speed", 1150, "rpm", "engine", [], false, true), // 1600 irl
	"gv": new CalcVar("Gas Velocity", 2100, "speed", "engine", [], false, true),
	"msc": new CalcVar("Material Stress Constant", 0.42, "count", "engine", [], false, true),
	"mas": new CalcVar("Max Allowable Stress", 57.5, "pressure", "engine", [], false, true),

	"npt": new CalcVar("Planet Teeth", 104, "count", "planetary", [], false, true), // 104 irl
	"nrt": new CalcVar("Ring Teeth", 156, "count", "planetary", [], false, true), // 156 irl
	"pts": new CalcVar("Tooth Size", 13.3, "count", "planetary", [], false, true),

	"est": new CalcVar("Engine Stroke", 369, "length", "cylinder", [], false, true),
	
	"crw": new CalcVar("Con rod width", 46.365, "length", "cylinder", [], false, true), // 46.365

	"vbo": new CalcVar("Valve Bore", 120, "length", "valve", [], false, true),
	"vs": new CalcVar("Valve Stroke", 370, "length", "valve", [], false, true),
	"vsa": new CalcVar("Valve Seat Angle", 45, "angle", "valve", [], false, true),
	"vsl": new CalcVar("Valve Stem Length", 120, "length", "valve", [], false, true),
	"mgp": new CalcVar("Max Gas Pressure", 6, "length", "valve", [], false, true), // 120 N/mm2
	"mps": new CalcVar("Mean Piston Speed", 275, "speed", "valve", [], false, true),
	"evt": new CalcVar("Exhaust Valve Temperature", 120, "length", "valve", [], false, true),

	"pdi": new CalcVar("Port Diameter", 1, "length", "valve", ["vbo", "mps", "gv"], true, true),
	"vlt": new CalcVar("Valve Lift", 1, "length", "valve", ["pdi", "vsa"], true, true),
	"vdt": new CalcVar("Valve Disc Thickness", 1, "length", "valve", ["msc", "pdi", "mgp", "mas"], true, true),
	"vhd": new CalcVar("Valve Head Diameter", 1, "length", "valve", ["pdi", "vdt", "vsa"], true, true),
	"vho": new CalcVar("Valve Head Opening", 1, "length", "valve", ["pdi", "vhd"], true, true),
	"vsw": new CalcVar("Valve Seating Width", 1, "length", "valve", ["pdi", "vhd"], true, true),
	"vsd": new CalcVar("Valve Stem Diameter", 1, "length", "valve", ["pdi"], true, true),

	"btd": new CalcVar("Bucket Tappet Diameter", 40, "length", "valve", [], false, true),
	"btl": new CalcVar("Bucket Tappet Length", 50, "length", "valve", [], false, true),
	"vsl": new CalcVar("Valve Stem Length", 100, "length", "valve", [], false, true),

	"flk": new CalcVar("Cam Flank", 35, "length", "valve", [], false, true),
	"ncd": new CalcVar("Cam Nose Diameter", 50, "length", "valve", [], false, true),
	"bcd": new CalcVar("Cam Base Diameter", 100, "length", "valve", [], false, true),
	"ccp": new CalcVar("Cam Clearance Ramp", 1, "length", "valve", [], false, true),



	"cht": new CalcVar("Piston Height", 405, "length", "cylinder", [], false, true), //+32 for 62.25 mm piston bore

	"cdi": new CalcVar("Piston Diameter", 83.42, "length", "cylinder", [], false, true), // 83.42 irl
		"cao": new CalcVar("Con Rod Attachment Offset", 150, "length", "cylinder", [], true, true),
		"crw": new CalcVar("Con Rod width", 46.365, "length", "cylinder", [], false, true), // 46.365
		"cch": new CalcVar("Piston-Con Rod Attachment Height", 354, "length", "cylinder", [], false, true), // 48.33
		"crl": new CalcVar("Con Rod Length", 810, "length", "cylinder", [], false, true), // 810 irl
		"csd": new CalcVar("cylinder Start Depth", 46.86, "length", "valve", [], false, true) //48.33

}


function calculateNumericalOutputs(){

	console.log("calculating");
	for (const [key, value] of Object.entries(vars)) {
		// console.log(key, value);
		if (value["dependentsShown"]){

			if (key == "pdi"){ // port diameter
				vars["pdi"].value = vars["cdi"].value * Math.sqrt(vars["mps"].value/vars["gv"].value)
				console.log("pdi val", vars["pdi"].value);

			} else if (key == "vlt"){ // valve lift
				vars["vlt"].value = 0.25*vars["pdi"].value/Math.cos(vars["vsa"].value*Math.PI/180)
				calculatedVars["vlt"].value = vars["vlt"].value;
				console.log("valve lift", vars["vlt"].value);

			} else if (key == "vdt"){ // valve disc thickness
				vars["vdt"].value = vars["msc"].value*vars["pdi"].value*Math.sqrt(vars["mgp"].value/vars["mas"].value)
				console.log(vars.vdt.value);
			} else if (key == "vhd"){ // valve head diameter
				vars["vhd"].value = vars["pdi"].value+2*(vars["vdt"].value * Math.sin((90-vars["vsa"].value)*Math.PI/180));
			} else if (key == "vho"){ // valve head opening
				vars["vho"].value = Math.sqrt(vars["pdi"].value**2 + vars["vhd"].value**2)
			} else if (key == "vsw"){ // valve seating width
				vars["vsw"].value = 0.5*(vars["vhd"].value - vars["pdi"].value);
			} else if (key == "vsd"){ // valve stem diameter
				vars["vsd"].value = vars["pdi"].value/8+4;
			}
		}
	
	}

	for (const [key, value] of Object.entries(vars)) {
		
		m = value.activated;
		// console.log(m);
		if (m == true){
			// console.log("activated", value.activated);
			var m = value["element"];
			m.value = value["value"];
		}
		// console.log(key, m.value)

	}
}

function updateCalculatedVars(){
	for (const [key, value] of Object.entries(calculatedVars)) {
		var xx = value["span"];
		xx.innerHTML = "<br><br>" + value["name"] + ": " + value.value + " " + currentUnits[value["type"]];
	}

}


function buildInputs(varsToMake){

	i = 0;
	console.log(varsToMake);
	console.log(vars);
	while (i<varsToMake.length){
		e = vars[varsToMake[i]];
		// console.log(e);
		if (e["activated"]){

			
			var xx = document.createElement("SPAN");
			xx.innerHTML = "<br><br>" + e["name"] + ": ";
			document.body.appendChild(xx);
			allElements.push(xx);

			var x = document.createElement("INPUT");
			x.setAttribute("type", "number");
			x.setAttribute("value", e.value);
			x.setAttribute("id", varsToMake[i]);
			document.body.appendChild(x);
			vars[varsToMake[i]].element = x;
			allElements.push(x);

			x.addEventListener("blur", function () {
				console.log("changed");
				drawingVars["flywheelAngle"] = Math.PI/2;
				drawingVars["planetAngle"] = Math.PI/2;
				
				vars[this.id].value = parseFloat(this.value);
				console.log("value changed", this.id)
				console.log("elements new value", this.id, vars[this.id].value);
				calculateNumericalOutputs();

			});

			var xy = document.createElement("SPAN");
			xy.innerHTML = " " + currentUnits[e["type"]];
			document.body.appendChild(xy);
			allElements.push(xy);
			
		}
		i+=1;

	}
}




	function buildCalculatedVars(){
		for (const [key, value] of Object.entries(calculatedVars)) {
			console.log(key, value);
			var xx = document.createElement("SPAN");
			xx.innerHTML = "<br><br>" + value["name"] + ": " + value.value + " " + currentUnits[value["type"]];
			document.body.appendChild(xx);
			calculatedVars[key]["span"] = xx;
		}
	}




	function buildDrawingVars(){
		for (const [key, value] of Object.entries(drawingVars)) {
			
			var xx = document.createElement("SPAN");
			xx.innerHTML = "<br><br>" + key + ": ";
			document.body.appendChild(xx);
			allElements.push(xx);

			var x = document.createElement("INPUT");
			x.setAttribute("type", "number");
			x.setAttribute("value", value);
			x.setAttribute("id", key);
			document.body.appendChild(x);
			allElements.push(x);
			
			x.addEventListener("blur", function () {
				console.log("changed");
				drawingVars[this.id] = parseFloat(this.value);
	
			});
		}
	}



	calculateNumericalOutputs();






	function mainloop(){
		// clearInterval(myInterval);
		const canvas = document.getElementById('myCanvas');
		const ctx = canvas.getContext('2d');
		h = canvas.height;
		w = canvas.width;
		ctx.clearRect(0, 0, w, h);

		scale = drawingVars["scale"]




		ts = vars["pts"].value*scale; // tooth size
		pt = vars["npt"].value; // planet teeth
		pd = pt*ts / Math.PI; // planet diameter
		rt = vars["nrt"].value; // ring teeth
		rd = rt*ts / Math.PI; // ring diameter
		ao = vars["cao"].value*scale; // attachment offset
		crl = vars["crl"].value*scale; // con rod length
		cdi = vars["cdi"].value*scale;// cylidner diameter
		cht = vars["cht"].value*scale;// cylinder height
		cch = vars["cch"].value*scale;// cyliner attachment

		// bdcMin = center[1] + (rd-pd)/2 - ao - crl;
		tdcInfo = calculateTDC(ctx, 0, [0,0], rd, pd, ao, crl);
		pauseNext = false;//checkToPause(tdcInfo);

		if (document.getElementById("pausewhenTDC").checked){
			pauseNext = checkToPause(tdcInfo);
		}




		planetaryHeight = vars["nrt"].value*vars["pts"].value/Math.PI;
		conRodHeight = vars["crl"].value - vars["cao"].value;
		valveHeight = vars["ncd"].value/2 + vars["bcd"].value/2 + vars["vsl"].value + vars["vdt"].value + vars["vsw"].value + vars["btl"].value;
		totalHeight = planetaryHeight + conRodHeight + valveHeight;
		

		center = [w/2,h/2+valveHeight/2];

		drawValve(ctx, [center[0]-vars["cdi"].value*scale/2, center[1]-(totalHeight-valveHeight)*scale], scale, drawingVars["camAngle"], Math.PI/2);

		drawValve(ctx, [center[0]+vars["cdi"].value*scale/2, center[1]-(totalHeight-valveHeight)*scale], scale, drawingVars["camAngle"]+Math.PI/2, Math.PI/2);
		
		drawPlanetary(ctx, [center[0], center[1]+(totalHeight-conRodHeight-planetaryHeight)*scale], scale, drawingVars["planetAngle"], drawingVars["flywheelAngle"]);

		if (pauseNext){
			console.log("pausing");
			togglePause();
		}


		// if (drawingVars["flywheelAngle"] < tdcAngle && drawingVars["flywheelAngle"] + drawingVars["calc angle change"] > tdcAngle){
		// 	angleChange = 
		// }

		drawingVars["flywheelAngle"] += drawingVars["calc angle change"];
		drawingVars["planetAngle"] -= drawingVars["calc angle change"] * (vars["nrt"].value/vars["npt"].value-1);
		drawingVars["camAngle"] = drawingVars["flywheelAngle"]/2;


		updateCalculatedVars();

		findMinTransAngle(center, ao, flywheelAngle, planetAngle, crl, pd, rd);

		// optimizeSizes(ctx, [center[0], center[1]+(totalHeight-conRodHeight-planetaryHeight)*scale], ao, flywheelAngle, planetAngle, crl, pd, rd);

	}



	function checkToPause(tdcInfo){
		dif = tdcInfo[1]-Math.PI*1.5

		if (drawingVars["flywheelAngle"] + drawingVars["calc angle change"] > tdcInfo[1] && drawingVars["flywheelAngle"] < tdcInfo[1]){ // tdc 1
				angleChange = tdcInfo[1]- drawingVars["flywheelAngle"];
				drawingVars["flywheelAngle"] += angleChange;
				drawingVars["planetAngle"] -= angleChange * (vars["nrt"].value/vars["npt"].value-1);
				return true;
		}
	
		a = Math.PI*3.5 - dif;
		if (drawingVars["flywheelAngle"] + drawingVars["calc angle change"] > a && drawingVars["flywheelAngle"] < a){ // tdc 2
				angleChange = a- drawingVars["flywheelAngle"];
				drawingVars["flywheelAngle"] += angleChange;
				drawingVars["planetAngle"] -= angleChange * (vars["nrt"].value/vars["npt"].value-1);
				return true;
		}

		if (drawingVars["flywheelAngle"] + drawingVars["calc angle change"] > Math.PI*4.5 && drawingVars["flywheelAngle"] < Math.PI*4.5){ // bdc 1
			console.log("bdc 1");
			drawingVars["planetAngle"] = Math.PI/2;
			drawingVars["flywheelAngle"] = Math.PI/2;
			return true;
		}

		if (drawingVars["flywheelAngle"] + drawingVars["calc angle change"] > Math.PI*2.5 && drawingVars["flywheelAngle"] < Math.PI*2.5){ // bdc 2
			console.log("bdc 2");
			angleDif = Math.PI * 2.5 - drawingVars["flywheelAngle"];
			console.log(angleDif);
			drawingVars["flywheelAngle"] = Math.PI*2.5;
			drawingVars["planetAngle"] = Math.PI*1.5;
			return true;
		}
		return false;
	}


	function findMinTransAngle(center, ao, flywheelAngle, planetAngle, conRodLength, pd, rd){
		d1 = (rd-pd)/2;
		d2 = ao;

		L = conRodLength;
		crl = conRodLength;
		b = (1-Math.sqrt(1+32*(d1/d2)**2))/(16*(d1/d2)**2);
		flywheelAngle = Math.PI*2.5-Math.acos(b);
		c = [center[0], center[1]];
		centerToPlanet = (rd-pd)/2
		pCenter = [c[0]+centerToPlanet*Math.cos(flywheelAngle), c[1]+centerToPlanet*Math.sin(flywheelAngle)];
		estAngle = -Math.PI/2 + (flywheelAngle-Math.PI/2)/2; // alpha
		estAngle*=-1;  
		aoCenter = [pCenter[0]+Math.cos(estAngle)*ao, pCenter[1]+Math.sin(estAngle)*ao];
		planetEdge = [c[0]+rd/2*Math.cos(flywheelAngle), c[1]+rd/2*Math.sin(flywheelAngle)];

		difX = c[0]-aoCenter[0];
		difY = Math.sqrt(crl**2-difX**2)
		realConRodSpot = [c[0], aoCenter[1]-difY];
		aaa = (realConRodSpot[1]-aoCenter[1]) / (realConRodSpot[0]-aoCenter[0]);

		// console.log("aaa", aaa);
		transAngle = Math.atan(aaa) + Math.PI;
		calculatedVars["mta"].value = transAngle*180/Math.PI-180;
		// console.log("trans angle --------------->", transAngle, b);



		var abcd = transAngle;
		// console.log(abcd);
		return abcd;
	}

	function tylerEqn2(center, ao, flywheelAngle, planetAngle, conRodLength, pd, rd, mta, b){
		d1 = (rd-pd)/2;
		d2 = ao;
		theta1 = b;
		L = conRodLength;
		crl = conRodLength;


		side1 = L/d1 * Math.sqrt(1/(Math.tan(mta)**2 + 1));

		side2 = sin(theta1) + d2/d1*sin(theta1/2)


	}


	function optimizeSizes(ctx, center, ao, flywheelAngle, planetAngle, conRodLength, pd, rd){
		togglePause();
		
		console.log("crl used", conRodLength/0.3)

		center = [0,0]
		// modify conRodLength and (rd-pd)/2 to minimize height
		//keep stroke constant
		let mta = 90;
		let i=0;
		while (mta>65.5 && i<1000){
			pd *= 1.001;
			rd *= 1.001;

			let crl = findConRodLength(ctx, 92*scale, pd, rd, ao);

			console.log(ao, 0, 0, crl, pd, rd)
			
			mta = findMinTransAngle([0,0], ao, 0, 0, crl, pd, rd) * 180 / Math.PI - 180;

			// console.log("min trans angle", mta)//, //mta[0]*180/Math.PI-180);
			
			// console.log("mta", mtaa);


			b = calculateHeight(ctx, [0,0], 0, rd, pd, ao, conRodLength)


			// console.log("height", ht/scale);
			// console.log("stroke1", b[1]/scale, "stroke2", b[2]/scale);
					console.log("mta", mta);
					console.log("iterations:", i);
					console.log("pd:", pd/scale);
					console.log("rd:", rd/scale);
					console.log("crl", crl/scale);
			i+=1;
		}

		console.log("-_-_-_-_-_-_-_-_-_-_-_-")
		console.log("mta final", mta);
		console.log("iterations:", i);
		console.log("pd:", pd/scale);
		console.log("rd:", rd/scale);
		console.log("crl", crl);
	}


	function findConRodLength(ctx, targetStroke, pd, rd, ao){
		var error = 100000;
		i = 0;
		crl = 810*scale;
		center = [0,0]
		flywheelAngle = 0;
		var lastCrl = crl;

		while (Math.abs(error)>0.1 && i<100){
			strokes = calculateHeight(ctx, center, flywheelAngle, rd, pd, ao, crl)
			stroke = strokes[2];
			newError = targetStroke-stroke;
			// console.log("crl", crl/scale, "stroke", strokes[2]/scale);
			// console.log("new error", newError/scale);
			if (Math.abs(error)<Math.abs(newError)){
				crl = lastCrl;
				break;
			}

			error = newError;
			lastCrl = crl;

			if (error>0){ // too short
				crl*=1.1;
			} else { // too long
				crl*=0.9;
			}

			i+=1;
		}

		console.log("result", crl/scale);
		return crl;
	}


	function calculateHeight(ctx, center, flywheelAngle, rd, pd, ao, crl) {
		tdc = calculateTDC(ctx, flywheelAngle, center, rd, pd, ao, crl)[0]
		bdcMax = (rd-pd)/2 + ao - crl;
		bdcMin = (rd-pd)/2 - ao - crl;

		// console.log("tdc, bdcmax, bdcmin", tdc, bdcMax, bdcMin);
		stroke1 = Math.abs(tdc-bdcMax);
		stroke2 = Math.abs(tdc-bdcMin);


		cht = vars["cht"].value*scale;// cylinder height
		csd = vars["csd"].value*scale;// cyliner start depth


		tdc += -cht + csd

		ht = center[1]-tdc + rd/2


		

		return [ht, stroke1, stroke2];//bdcMax; //+ rd/2;
	}








	function tylersEqn(ctx, center, ao, flywheelAngle, planetAngle, conRodLength, pd, rd){
		return [0,0];
		d1 = (rd-pd)/2;
		d2 = ao;
		theta2 = planetAngle - Math.PI/2;
		theta1 = flywheelAngle - Math.PI/2;
		L = conRodLength;

		d1/=scale;
		d2/=scale;
		L/=scale;


		minTranAngleAngle = Math.acos((1+Math.sqrt(1+4*(8*d1/d2)**2))/(16*(d1/d2)**2));
			


		// console.log()
		// d1 = 110
		// d2 = 150
		// L = 810

		// theta1 = 224.7*Math.PI/180;
		// theta2 = theta1/2;

		// theta1 = 224.752*Math.PI/180;
		// theta2 = theta1/2;
		// console.log("angle", theta1/Math.PI*180);

		height = -d1*Math.cos(theta1) - d2*Math.cos(theta1/2) + Math.sqrt(L**2 - (-d1*Math.sin(theta1) + d2*Math.sin(theta1/2))**2 );
		// console.log("d1=",d1, "d2=",d2, "L=", L);
		// console.log("height", (height-550));

		

		if (height>maxPt){
			maxPt = height;
		}
		if (height<minPt){
			minPt = height;
		}
		// console.log("big difference", (maxPt-minPt));

		return height*scale;
}


		 	maxPt = -1000;
	minPt = 10000;


traDir = 1;



	function drawPlanetary(ctx, center, scale, planetAngle, flywheelAngle){

		drawGears = true;

		ts = vars["pts"].value*scale; // tooth size
		pt = vars["npt"].value; // planet teeth
		pd = pt*ts / Math.PI; // planet diameter
		rt = vars["nrt"].value; // ring teeth
		rd = rt*ts / Math.PI; // ring diameter
		ao = vars["cao"].value*scale; // attachment offset
		crl = vars["crl"].value*scale; // con rod length
		cdi = vars["cdi"].value*scale;// cylidner diameter
		cht = vars["cht"].value*scale;// cylinder height
		cch = vars["cch"].value*scale;// cyliner attachment

		calculatedVars["pgd"].value = pd/scale;
		calculatedVars["rgd"].value = rd/scale;





		planetCenter = [center[0]+(rd-pd)/2*Math.cos(flywheelAngle), center[1]+ (rd-pd)/2*Math.sin(flywheelAngle)];
		attachmentPoint = [planetCenter[0]+ao*Math.cos(planetAngle), planetCenter[1]+ ao*Math.sin(planetAngle)]

		// draw ring
		ctx.beginPath();
		ctx.arc(center[0], center[1], rd/2+ts*3, 0, Math.PI*2);
		ctx.fillStyle="yellow";
		ctx.fill();

		planetToothAngle = 2*Math.PI/rt;
		a = planetToothAngle/2;
		if (drawGears){
			ctx.beginPath();
			while (a<=2*Math.PI+planetToothAngle){
				ctx.arc(center[0], center[1], rd/2-ts/2, a, a); // innner
				a+=planetToothAngle*0.5;
				ctx.arc(center[0], center[1], rd/2+ts/2, a, a); // outer
				ctx.arc(center[0], center[1], rd/2+ts/2, a, a);
				a+=planetToothAngle*0.5;
			}

			ctx.fillStyle="white";
			ctx.fill();

			ctx.stroke();
		}

		// draw planet
		ringToothAngle = 2*Math.PI/pt;

		a=planetAngle;

		if (drawGears){
			ctx.beginPath();
			while (a<=2*Math.PI+planetAngle+ringToothAngle){
				ctx.arc(planetCenter[0], planetCenter[1], pd/2-ts/2, a, a); // innner
				a+=ringToothAngle*0.5;
				ctx.arc(planetCenter[0], planetCenter[1], pd/2+ts/2, a, a); // outer
				ctx.arc(planetCenter[0], planetCenter[1], pd/2+ts/2, a, a);
				a+=ringToothAngle*0.5;
			}
			// ctx.arc(planetCenter[0], planetCenter[1], pd/2, 0, Math.PI*2);
			ctx.fillStyle = "red";
			ctx.fill();
			ctx.stroke();
		}

		// draw attachment
		ctx.beginPath();
		ctx.arc(attachmentPoint[0], attachmentPoint[1], 5, 0, Math.PI*2);
		ctx.stroke();



		// draw con rod
		var difX = center[0]-attachmentPoint[0]
		var difY = Math.sqrt(crl**2 - difX**2);

		// console.log(difY, difX[0], crl);

		tra = calculatedVars["cra"].value;
		newTra = Math.abs(Math.atan(difY/difX) * 180 / Math.PI);

		if (tra>newTra && traDir>0){
			traDir = -1;
		} else 	if (tra<newTra && traDir<0){
			traDir = 1;
			// togglePause();
		}

		if (difX != 0){
			calculatedVars["cra"].value = newTra
		} else {
			calculatedVars["cra"].value = 0;
		}






		tdc = calculateTDC(ctx, flywheelAngle, center, rd, pd, ao, crl)[0];


		bdcMax = center[1] + (rd-pd)/2 + ao - crl;
		bdcMin = center[1] + (rd-pd)/2 - ao - crl;

		calculatedVars["ssr"].value = Math.abs(tdc-bdcMin)/scale;
		calculatedVars["lsr"].value = Math.abs(tdc-bdcMax)/scale;

		calculatedVars["rcb"].value = Math.abs(center[1]-bdcMin);

		extraDepth = - cch + vars["csd"].value*scale;
		

		// ctx.beginPath();
		// ctx.moveTo(0, tdc);
		// ctx.lineTo(1000, tdc);
		// ctx.stroke()

		// ctx.beginPath();
		// ctx.moveTo(0, bdcMax);
		// ctx.lineTo(1000, bdcMax);
		// ctx.stroke();


		// console.log("extr", extraDepth);


		cylinderBottom = bdcMax+extraDepth;
		cylinderTop = tdc - cch;

		// console.log(cylinderBottom);

		// draw cylinder
		ctx.beginPath();
		ctx.rect(center[0]-cdi/2-2, cylinderBottom, cdi+4, cylinderTop - cylinderBottom);
		ctx.fillStyle = "blue";
		ctx.fill();
		ctx.stroke();

		// draw piston
		ctx.beginPath();
		ctx.rect(center[0]-cdi/2, attachmentPoint[1]-difY-cch, cdi, cht);
		ctx.lineWidth = 1;
		ctx.fillStyle = "green";
		ctx.fill();
		ctx.stroke();





		ht = tylersEqn(ctx, center, ao, flywheelAngle, planetAngle, crl, pd, rd);
		ht = center[1] - ht;



		// ctx.beginPath();
		// ctx.moveTo(0, ht);
		// ctx.lineTo(1000, ht);
		// ctx.stroke();




		// draw con rod

		ctx.beginPath();
		// ctx.lineWidth = vars.crw.value*scale;
		ctx.moveTo(attachmentPoint[0], attachmentPoint[1]); // attachment point
		ctx.lineTo(center[0], attachmentPoint[1]-difY); // top
		ctx.stroke();

		cray = (Math.atan(difY/difX) * 180 / Math.PI)
		offsetX = vars.crw.value*scale/2;
		ctx.beginPath()
		ctx.moveTo(attachmentPoint[0]+offsetX, attachmentPoint[1]); // attachment point
		ctx.lineTo(center[0]+offsetX, attachmentPoint[1]-difY); // top
		ctx.lineTo(center[0]-offsetX, attachmentPoint[1]-difY); // top
		ctx.lineTo(attachmentPoint[0]-offsetX, attachmentPoint[1]);
		ctx.lineTo(attachmentPoint[0]+offsetX, attachmentPoint[1]);
		ctx.strokeStyle="gray";
		ctx.fillStyle="gray";
		ctx.fill();
		ctx.stroke();
		ctx.strokeStyle="black";

		

		tdcAngle = 0.5*Math.PI - 0.0005 * Math.PI*ao/scale;//Math.PI + 4/3 * Math.PI + 1/3*Math.PI*ao/pd/2;
		centerToAtchPt = (rd-pd)/2+ao;
		tdcAtchPtY = center[1] - centerToAtchPt*Math.sin(tdcAngle);
		tdcAtchPtXdif = centerToAtchPt*Math.cos(tdcAngle);
		tdcConRodY = tdcAtchPtY - Math.sqrt(crl**2 - tdcAtchPtXdif**2);
		tdcPt = 0;


		craa = 0.5*Math.PI - 1/3 * ao/rd * Math.PI;
		// console.log("craa", craa*180/Math.PI);

		dx = Math.cos(planetAngle)*ao;
		dy = Math.sin(planetAngle)*ao;
			
		// ctx.beginPath();
		// ctx.moveTo(planetCenter[0], planetCenter[1])
		// ctx.lineTo(planetCenter[0]+dx, planetCenter[1]+dy)
		// ctx.stroke();

		

		dx = Math.cos(flywheelAngle)*rd/2;
		dy = Math.sin(flywheelAngle)*rd/2;
			
		// ctx.beginPath();

		// ctx.strokeStyle="blue";
		// ctx.moveTo(center[0], center[1])
		// ctx.lineTo(center[0]+dx, center[1]+dy)

		// ctx.stroke();
		ctx.strokeStyle="black";




		// ctx.moveTo(attachmentPoint[0], attachmentPoint[1]); // attachment point
		// ctx.lineTo(center[0], attachmentPoint[1]-difY); // top
		// ctx.rect(center[0]-cdi/2, cylinderBottom-cch+cht, cdi, -200);


		conRodLine = [[attachmentPoint[0]+offsetX, attachmentPoint[1]], [center[0]+offsetX, attachmentPoint[1]-difY]];
		cylinderLine = [[center[0]+cdi/2, cylinderBottom-cch+cht], [center[0]+cdi/2, cylinderBottom-cch+cht-200]];
		a = line_intersection(conRodLine, cylinderLine);
		// intersection arc
		ctx.beginPath();
		if (a!=-1){
			if (a[1]<cylinderBottom && a[1]>attachmentPoint[1]-difY){
				if (a[1]<highestHitPoint){

					highestHitPoint = a[1]
					calculatedVars["cpi"].value = (cylinderBottom-a[1])/scale;
				}
				ctx.arc(a[0], a[1], 5, 0, 2*Math.PI);
				ctx.fillStyle = "red";
				ctx.fill();
			}
		}
		// ctx.moveTo(0,highestHitPoint);
		// ctx.lineTo(1000,highestHitPoint);
		// ctx.stroke();


		// left side
		conRodLine = [[attachmentPoint[0]-offsetX, attachmentPoint[1]], [center[0]-offsetX, attachmentPoint[1]-difY]];
		cylinderLine = [[center[0]-cdi/2, cylinderBottom-cch+cht], [center[0]-cdi/2, cylinderBottom-cch+cht-200]];
		a = line_intersection(conRodLine, cylinderLine);
		// intersection arc
		ctx.beginPath();
		if (a!=-1){
			if (a[1]<cylinderBottom && a[1]>attachmentPoint[1]-difY){
				if (a[1]<highestHitPoint){
					highestHitPoint = a[1]
					calculatedVars["cpi"].value = (cylinderBottom-a[1])/scale;
				}
				ctx.arc(a[0], a[1], 5, 0, 2*Math.PI);
				ctx.fillStyle = "red";
				ctx.fill();
			}
		}


		







	}
	highestHitPoint = 10000;

		// cdi = vars["cdi"].value*scale;// cylinder diameter
		// cht = vars["cht"].value*scale;// cylinder height
		// cch = vars["cch"].value*scale;// cyliner attachment




function calculateTDC(ctx, flywheelAngle, center, rd, pd, ao, crl){
		// center = [0,0]

		flywheelAngle = Math.PI*1.5;

		lastError = 1000;
		while (flywheelAngle<Math.PI*2){
			

			c = [center[0], center[1]];

			centerToPlanet = (rd-pd)/2
			pCenter = [c[0]+centerToPlanet*Math.cos(flywheelAngle), c[1]+centerToPlanet*Math.sin(flywheelAngle)];
			estAngle = -Math.PI/2 + (flywheelAngle-Math.PI/2)/2; // alpha
			estAngle*=-1;  
			aoCenter = [pCenter[0]+Math.cos(estAngle)*ao, pCenter[1]+Math.sin(estAngle)*ao];
			planetEdge = [c[0]+rd/2*Math.cos(flywheelAngle), c[1]+rd/2*Math.sin(flywheelAngle)];

			transAngle = Math.atan((planetEdge[1]-aoCenter[1]) / (planetEdge[0]-aoCenter[0])) + Math.PI;
			planetEdge1 = [aoCenter[0]+crl*Math.cos(transAngle), aoCenter[1]+crl*Math.sin(transAngle)];

			difX = c[0]-aoCenter[0];
			difY = Math.sqrt(crl**2-difX**2)
			realConRodSpot = [c[0], aoCenter[1]-difY];


			realTransAngle = Math.atan((realConRodSpot[1]-aoCenter[1]) / (realConRodSpot[0]-aoCenter[0])) + Math.PI;

			planetEdge2 = [aoCenter[0]+crl*Math.cos(realTransAngle), aoCenter[1]+crl*Math.sin(realTransAngle)];

			error = ((planetEdge2[0] - planetEdge1[0])**2 + (planetEdge2[1] - planetEdge1[1])**2)**0.5;

			if (error>lastError){
				// console.log("broke");
				break;
			}

			lastError = error;
			flywheelAngle += 0.001;
		}

		// ctx.beginPath();
		// ctx.arc(aoCenter[0], aoCenter[1], 5, 0, 2*Math.PI);
		// ctx.stroke();
		// ctx.beginPath();
		// ctx.moveTo(c[0], c[1]);
		// ctx.lineTo(pCenter[0],pCenter[1]);
		// ctx.lineTo(aoCenter[0], aoCenter[1]);
		// ctx.lineTo(planetEdge1[0], planetEdge1[1]);
		// ctx.moveTo(aoCenter[0], aoCenter[1]);
		// ctx.lineTo(planetEdge2[0], planetEdge2[1]);
		// ctx.stroke();

		tdc = planetEdge2[1];
		return [tdc, flywheelAngle];

}





var valveHeights = [];

	function drawValve(ctx, center, scale, orientation, edgeAngle){

		flank = vars["flk"].value*scale;
		nd = vars["ncd"].value*scale; // nose diameter
		bd = vars["bcd"].value*scale; // base circle diameter
		cr = vars["ccp"].value*scale// clearance ramp

		btd = vars["btd"].value*scale;
		btl = vars["btl"].value*scale;
		vsl = vars["vsl"].value*scale;
		vho = vars["vho"].value*scale; // valve head opening
		// console.log(btl)


		vsd = vars["vsd"].value*scale; // valve stem diameter
		vdt = vars["vdt"].value*scale; // valve disc thickness
		var vsw = vars["vsw"].value*scale; // valve seating width
		pdi = vars["pdi"].value*scale;
		var vht = vsw; // valve head thickness
		vhd = vars["vhd"].value*scale;

		realCenter = [center[0], center[1]];
		center = [0,0];

		// clearance ramp
		a = Math.sqrt((bd/2)**2 - cr**2);
		// a = 30
		theta = Math.atan((cr+flank)/(nd/2-a))+Math.PI/2;
		// theta = Math.PI*0.1
		rightAngleFromTheta = Math.PI*0.5 - theta;

		pt1 = [center[0] - a*Math.cos(theta), center[1] - a*Math.sin(theta)]; // tangent point

		
		pt2 = [pt1[0]-cr*Math.sin(theta), pt1[1]+cr*Math.cos(theta)];
		pt3 = [pt1[0]+cr*Math.sin(theta), pt1[1]-cr*Math.cos(theta)];

		pt4 = [pt3[0]+flank*Math.sin(theta), pt3[1]-flank*Math.cos(theta)];

		n_center = [pt4[0] + nd/2*Math.cos(theta), pt4[1] + (nd/2)*Math.sin(theta)];

		theta1 = Math.atan((pt2[1]-center[1])/(pt2[0]-center[0]))



		b = Math.sqrt((center[1]-n_center[1])**2 - ((bd-nd)/2)**2)
		theta2 = Math.PI - Math.atan((bd-nd)/2/b)

		
		pt5 = [center[0] - bd/2*Math.cos(theta2), center[1] - bd/2*Math.sin(theta2)]; // tangent point
		pt6 = [n_center[0] - nd/2*Math.cos(theta2), n_center[1] - nd/2*Math.sin(theta2)]


		shortestLength = bd/2;
		longestLength = Math.sqrt((center[0]-n_center[0])**2 + (center[1]-n_center[1]))**2 + nd/2;
		trueValveLift = longestLength-shortestLength;
		calculatedVars["rvl"].value = Math.abs(trueValveLift);

		pt1 = rotate(center, pt1, orientation);
		pt2 = rotate(center, pt2, orientation);
		pt3 = rotate(center, pt3, orientation);
		pt4 = rotate(center, pt4, orientation);
		pt5 = rotate(center, pt5, orientation);
		pt6 = rotate(center, pt6, orientation);

		n_center = rotate(center, n_center, orientation)

		theta1 += orientation;
		theta2 += orientation;
		theta += orientation;



		ctx.beginPath();

		// base circle
		ctx.arc(center[0]+realCenter[0], center[1]+realCenter[1], bd/2, theta2+Math.PI, theta1+Math.PI);
		// ctx.arc(center[0], center[1], bd/2, 0, 2*Math.PI);
		

		// clearance ramp size
		// ctx.moveTo(pt1[0], pt1[1]);
		ctx.lineTo(pt2[0]+realCenter[0], pt2[1]+realCenter[1]);
		ctx.lineTo(pt3[0]+realCenter[0], pt3[1]+realCenter[1]);
		ctx.lineTo(pt4[0]+realCenter[0], pt4[1]+realCenter[1]);

		// nose circle
		ctx.arc(n_center[0]+realCenter[0], n_center[1]+realCenter[1], nd/2, theta+Math.PI, theta2+Math.PI);
		// ctx.arc(n_center[0], n_center[1], nd/2, 0, 2*Math.PI);
		// ctx.stroke()

		// return side (normal tangent)
		// ctx.moveTo(pt5[0], pt5[1]);
		ctx.lineTo(pt5[0]+realCenter[0], pt5[1]+realCenter[1]);
		ctx.lineTo(pt5[0]+realCenter[0], pt5[1]+realCenter[1]);
		ctx.lineTo(pt6[0]+realCenter[0], pt6[1]+realCenter[1]);
		// ctx.fill();
		// ctx.stroke();

		// ctx.beginPath();
		ctx.fillStyle = "#800080";
		ctx.fill();
		ctx.stroke();


		len = 1000

		i = 0;
		lowestPoint = -1;
		numPoints = 10;
		while (i<numPoints){
			pt8 = [center[0]+btd*0.5*(i/numPoints*2-1), center[1]]; // *0.5*(i/numPoints*2-1)
			pt7 = [pt8[0]+Math.cos(edgeAngle)*len, pt8[1]+Math.sin(edgeAngle)*len];
			l = findCamIntersection(pt7, pt2, pt4, pt6, pt8, center, nd);
			if (l[1] > lowestPoint) {
				lowestPoint = l[1];
			}
			i+=1;
		}

		l[1] = lowestPoint + realCenter[1];

	// function drawValveBody(ctx, base){

		base = l;



		

		// make valve head opening
		ctx.beginPath();
		ctx.moveTo(center[0]+realCenter[0]+pdi/2, center[1]+realCenter[1]+shortestLength+btl+vsl);
		// ctx.lineTo(center[0]+realCenter[0]+pdi/2, center[1]+realCenter[1]+shortestLength+btl+vsl);
		ctx.lineTo(center[0]+realCenter[0]+pdi/2, center[1]+realCenter[1]+shortestLength+btl+vsl/2);
		ctx.lineTo(center[0]+realCenter[0]-pdi/2, center[1]+realCenter[1]+shortestLength+btl+vsl/2);
		ctx.lineTo(center[0]+realCenter[0]-pdi/2, center[1]+realCenter[1]+shortestLength+btl+vsl);

		ctx.lineTo(center[0]+realCenter[0]-pdi/2-vsw, center[1]+realCenter[1]+shortestLength+btl+vsl+vsw); // fillet


		// d3 (bottom, inside cylinder)
		ctx.lineTo(center[0]+realCenter[0]-vho/2, center[1]+realCenter[1]+shortestLength+btl+vsl+vsw);
		ctx.lineTo(center[0]+realCenter[0]-vho/2, center[1]+realCenter[1]+shortestLength+btl+vsl+vsw+vsl/2);
		ctx.lineTo(center[0]+realCenter[0]+vho/2, center[1]+realCenter[1]+shortestLength+btl+vsl+vsw+vsl/2);
		ctx.lineTo(center[0]+realCenter[0]+vho/2, center[1]+realCenter[1]+shortestLength+btl+vsl+vsw);
		ctx.lineTo(center[0]+realCenter[0]+pdi/2+vsw, center[1]+realCenter[1]+shortestLength+btl+vsl+vsw);
		ctx.lineTo(center[0]+realCenter[0]+pdi/2, center[1]+realCenter[1]+shortestLength+btl+vsl);
		ctx.fillStyle="white";

		ctx.fill();

		// ctx.rect(center[0]+realCenter[0]-pdi/2, center[1]+realCenter[1]+shortestLength+btl+vsl, pdi, -vsl/2);
		// ctx.rect(center[0]+realCenter[0]-vho/2, center[1]+realCenter[1]+shortestLength+btl+vsl+vsw, vho, vsl/2); // d3


		ctx.stroke();




		// // make valve
		// if (valveNum==1){
		// 	valveNum = 0;
		// } else{
		// 	valveNum = 1;
		// 	valveHeights.push(base[1]);
		// 	valveHeights.push(orientation*180/Math.PI);
		// 	// console.log(base[1], orientation*180/Math.PI)
		// 	// console.log(valveHeights.length);
		// 	if (valveHeights.length>500){
		// 		console.log(valveHeights);
		// 		togglePause();
		// 		res = listToDictMsgs(valveHeights);
		// 		sendCsv("delete", res);
		// 		valveHeights = [];
		// 	}
		// }


		ctx.beginPath();

		ctx.rect(center[0]+realCenter[0]-btd/2, base[1], btd, btl); // bucket tappet


		ctx.rect(center[0]+realCenter[0]-vsd/2, base[1]+btl, vsd, vsl); // valve stem


		r = (pdi-vsd)/2;
		// console.log(pdi, vsw);
		ctx.moveTo(center[0]+realCenter[0]-vsd/2, base[1]+btl+vsl-r)
		ctx.arc(center[0]+realCenter[0]-vhd/2+vsd/2, base[1]+btl+vsl-r, r, 0, Math.PI/2) // rounding left side

		ctx.moveTo(center[0]+realCenter[0]+vhd/2, base[1]+btl+vsl)
		ctx.arc(center[0]+realCenter[0]+vhd/2-vsd/2, base[1]+btl+vsl-r, r, Math.PI/2, Math.PI) // rounding right side

		// thing between valve disc and stem
		ctx.moveTo(center[0]+realCenter[0]-pdi/2, base[1]+btl+vsl); // top left
		ctx.lineTo(center[0]+realCenter[0]+pdi/2, base[1]+btl+vsl); // top right
		ctx.lineTo(center[0]+realCenter[0]+vhd/2, base[1]+btl+vsl+vsw); // bottom right
		ctx.lineTo(center[0]+realCenter[0]-vhd/2, base[1]+btl+vsl+vsw); // bottom left
		ctx.lineTo(center[0]+realCenter[0]-vhd/2+vsw, base[1]+btl+vsl); // top left

		// ctx.rect(center[0]+realCenter[0]-vhd/2, base[1]+btl+vsl, vhd, vsw); 

		ctx.rect(center[0]+realCenter[0]-vhd/2, base[1]+btl+vsl+vsw, vhd, vdt); // valve disc



		ctx.stroke();


	}
	valveNum = 0;

	function findCamIntersection(pt7, pt2, pt4, pt6, pt8, center, nd){
		l = line_intersection([pt8, pt7], [pt5, pt6])
		if (!isBetween(pt5, pt6, l)){
			l=-1;
		}
		if (!isBetween(pt8, pt7, l)){
			l=-1;
		}
		if (l == -1){
			l = line_intersection([pt8, pt7], [pt2, pt4])
			if (!isBetween(pt2, pt4, l)){
				l=-1
			}
			if (!isBetween(pt8, pt7, l)){
				l=-1
			}
		}
		if (l == -1){
			l = line_intersection([pt8, pt7], [pt6, pt4])
			if (!isBetween(pt6, pt4, l)){
				l=-1
			}
			else if (!isBetween(pt8, pt7, l)){
				l=-1
			} else {
				// in nose
				xxx = inteceptCircleLineSeg(nd/2, n_center, pt8, pt7);
				d1 = (xxx[0].x-pt8[0])**2 + (xxx[0].y-pt8[1])**2;
				d2 = (xxx[1].x-pt8[0])**2 + (xxx[1].y-pt8[1])**2;
				if (d1>d2){
					l = [xxx[0].x, xxx[0].y];
				} else {
					l = [xxx[1].x, xxx[1].y];
				}
			}
		}
		if (l==-1){ // in base
			xxx = inteceptCircleLineSeg(bd/2, center, pt8, pt7);
			l = [xxx[0].x, xxx[0].y];


			
		}
		return l;
	}


	function inteceptCircleLineSeg(rad, circleCenter, a, b){

	    var a, b, c, d, u1, u2, ret, retP1, retP2, v1, v2;
	    v1 = {};
	    v2 = {};
	    v1.x = b[0] - a[0];
	    v1.y = b[1] - a[1];
	    v2.x = a[0] - circleCenter[0];
	    v2.y = a[1] - circleCenter[1];
	    b = (v1.x * v2.x + v1.y * v2.y);
	    c = 2 * (v1.x * v1.x + v1.y * v1.y);
	    b *= -2;
	    d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - rad * rad));
	    if(isNaN(d)){ // no intercept
	        return [];
	    }
	    u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line
	    u2 = (b + d) / c;    
	    retP1 = {};   // return points
	    retP2 = {}  
	    ret = []; // return array
	    if(u1 <= 1 && u1 >= 0){  // add point if on the line segment
	        retP1.x = a[0] + v1.x * u1;
	        retP1.y = a[1] + v1.y * u1;
	        ret[0] = retP1;
	    }
	    if(u2 <= 1 && u2 >= 0){  // second add point if on the line segment
	        retP2.x = a[0] + v1.x * u2;
	        retP2.y = a[1] + v1.y * u2;
	        ret[ret.length] = retP2;
	    }       
	    return ret;
	}


	function line_intersection(line1, line2){
	    xdiff = [line1[0][0] - line1[1][0], line2[0][0] - line2[1][0]]
	    ydiff = [line1[0][1] - line1[1][1], line2[0][1] - line2[1][1]]

	    function det(a, b){
	        return a[0] * b[1] - a[1] * b[0];
	    }

	    div = det(xdiff, ydiff)
	    if (div == 0){
	       return -1;
	    }

	    d = [det(line1[0], line1[1]), det(line2[0], line2[1])]
	    x = det(d, xdiff) / div
	    y = det(d, ydiff) / div
	    return [x, y]
	}


	function isBetween(a, b, c){ // c is the point checking

		if (c[0]>a[0] && c[0]>b[0]){
			return false;
		} if (c[1]>a[1] && c[1]>b[1]){
			return false;
		}

		if (c[0]<a[0] && c[0]<b[0]){
			return false;
		} if (c[1]<a[1] && c[1]<b[1]){
			return false;
		}
		return true;

	}


	function rotate(origin, point, angle){
		d = Math.sqrt((origin[0]-point[0])**2 + (origin[1]-point[1])**2);
		if (origin[0] == point[0]){
			if (origin[1]>point[1]){
				a = 3*Math.PI/2;
			} else{
				a = Math.PI/2;
			}
		
		} else {

			a = Math.atan((origin[1]-point[1]) / (origin[0]-point[0]));
			if (origin[0] > point[0]) {
				a+=Math.PI;
			}
		}
		// console.log(a)

		a += angle;

		n = [origin[0] + Math.cos(a)*d, origin[1] + Math.sin(a)*d];

		return n;

	}


	// var myInterval = setInterval(mainloop, 10);



	function togglePause(){
		if (paused){
			myInterval = setInterval(mainloop, 100);
			document.getElementById('pauseButton').value = "pause";
			paused = false;
		} else {
			clearInterval(myInterval);
			document.getElementById('pauseButton').value = "resume";
			paused = true;
		}
	}



	startMeasure = false;

	function moveEvent(event){
		if (startMeasure!=false){
			// console.log(event.x, event.y); 
		}
	}

	function clickEvent(event){
		const canvas = document.getElementById('myCanvas');
		const ctx = canvas.getContext('2d');
		const rect = canvas.getBoundingClientRect()
		const x = event.clientX - rect.left
    const y = event.clientY - rect.top

		if (startMeasure == false){
			startMeasure = [x, y];
			ctx.beginPath();
			ctx.arc(x,y, 5, 0, 2*Math.PI)
			ctx.stroke();

		} else {
			

			calculatedVars["msd"].value = ((x-startMeasure[0])**2 + (y-startMeasure[1])**2)**0.5/drawingVars["scale"];

			

			ctx.beginPath();
			ctx.moveTo(startMeasure[0], startMeasure[1]);
			ctx.lineTo(x, y);
			ctx.arc(x,y, 5, 0, 2*Math.PI)
			ctx.stroke();

			startMeasure = false;
			updateCalculatedVars();
		}

	}


function sendCsv(csvName, fileData) {
	console.log("Sending csv");
	keyys = Object.keys(fileData);
	console.log("names: " + keyys);
	var csvData = [];
	i=0;
	while (i<keyys.length){
		csvData.push(fileData[keyys[i]]);
		i+=1;
	}
	csvData = csvData[0].map((_, colIndex) => csvData.map(row => row[colIndex]));
	csvData.splice(0, 0, keyys);

	let csvContent = "data:text/csv;charset=utf-8," + csvData.map(e => e.join(",")).join("\n");
	var encodedUri = encodeURI(csvContent);
	var link = document.createElement('a');
	link.setAttribute('href', encodedUri);    
	link.setAttribute('download', csvName + '.csv');    
	link.click();
}


function listToDictMsgs(msgs){
	res = {"angle":[], "valve height": []};
	k = Object.keys(res);
	i = 0;
	while (i<msgs.length){
		res[k[i%2]].push(msgs[i]);
		i+=1;
	}
	return res;
}


// given:
// bore
// stroke
// valve seat angle
// gas velocity
// stem length
// engine speed
// max gas pressure
// mean piston speed
// exhaust valve temperature
// material stress constant
// allowable stress


</script>



<html>
<link rel="shortcut icon" href="">
<a href="https://www.researchgate.net/publication/306070365_Diesel_Engine_Exhaust_Valve_Design_and_Optimization">Source1</a>	




</html>

<script>
	


	// buildNumericalInputs();
	// buildNumericalOutputs();

	// buildDrawingInputs();
	
	buildDrawingVars();
	calculateNumericalOutputs();
	buildInputs(Object.keys(vars));
	buildCalculatedVars();

</script>
<html>
<br>
<input type="button", id="pauseButton" value="pause" onclick="togglePause();"><br>
Pause at TDC or BDC: <input type="checkbox" id="pausewhenTDC"><br><br>

<canvas id="myCanvas" width="1000px" height="1000px" style="background: 'white'; " onmousedown="clickEvent(event);" onmousemove="moveEvent(event);">
</html>
<script>
var myInterval = setInterval(mainloop, drawingVars["time delay"]);
	
	</script>